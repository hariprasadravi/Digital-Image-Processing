// EE569 Homework Assignment #2// Date:     Oct 9, 2016// Name:     Hariprasad Ravishankar// ID:       8991379333// Email:    hravisha@usc.edu#include <stdio.h>#include <iostream>#include <stdlib.h>#include <algorithm>#include <math.h>#include <unordered_map>#include <vector>using namespace std;int main(int argc, char *argv[]){	// Define file pointer and variables	FILE *file;	int BytesPerPixel;	int Sizeh = 256;	int Sizew = 256;	// Check for proper syntax	if (argc < 3){		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;		cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Width = 256] [Height = 256]" << endl;		return 0;	}		// Check if image is grayscale or color	if (argc < 4){		BytesPerPixel = 1; // default is grey image	} 	else {		BytesPerPixel = atoi(argv[3]);		// Check if size is specified		if (argc >= 5){			Sizew = atoi(argv[4]);			Sizeh = atoi(argv[5]);		}	}		// Allocate image data array	unsigned char Imagedata[Sizeh][Sizew][BytesPerPixel];	// Read image (filename specified by first argument) into image data matrix	if (!(file=fopen(argv[1],"rb"))) {		cout << "Cannot open file: " << argv[1] <<endl;		exit(1);	}	fread(Imagedata, sizeof(unsigned char), Sizew*Sizeh*BytesPerPixel, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////	// Median filter	// Pre-assigning Filtered image matrix	unsigned char Filtered_Image[Sizeh][Sizew][BytesPerPixel];	for(int k=0;k<BytesPerPixel;k++){		for(int i=0;i<Sizeh;i++){			for(int j=0;j<Sizew;j++){				Filtered_Image[i][j][k] = 0;			}		}	}		/// new vector	vector<int> v;	// Applying Median filter recursively	for(int iter = 0; iter <3;iter++){		for(int k=0;k<BytesPerPixel;k++){			for(int l=1;l< Sizeh-1;l++){				for(int w=1;w< Sizew-1;w++){					//3 x 3 window					for(int i=-1;i<2;i++){						for(int j=-1;j<2;j++){							v.push_back(Imagedata[i+l][j+w][k]);						}					}					// sorting					sort(v.begin(),v.end());					// median					Filtered_Image[l][w][k] = (unsigned char)v[4];					v.clear();				}			}		}		// copying image data for next iteration		for(int k=0;k<BytesPerPixel;k++){			for(int i=0;i<Sizeh;i++){				for(int j=0;j<Sizew;j++){					Imagedata[i][j][k] = Filtered_Image[i][j][k];				}			}		}	}  	///////////////////////////////////////////////////////////////////////////////////////////////	// Thresholding based on mode  	double count[256] ={0};  	int mode[3] = {0};  	int index;	// Calculating the Probability of Colour Intensity //	for(int k=0; k< BytesPerPixel;k++){		for(int i = 0; i < Sizeh; i++){			for(int j=0;j<Sizew;j++){				index = Imagedata[i][j][k];				count[index]+=1;			}		}		//// Calculating mode for each channel ////		mode[k] = distance(count,max_element(count,count + 256));				//// Clearing count ////		for(int i=0;i< 256;i++){			count[i]=0;		}	}	//--------------------------------------------------------------------------------------------  		unsigned char Binary_image[Sizeh][Sizew][BytesPerPixel];	int median = 0;	///// Thresholding based on mode //////	for(int k=0;k<BytesPerPixel;k++){		for(int i=0;i<Sizeh;i++){			for(int j=0;j<Sizew;j++){				Binary_image[i][j][k] = 0;			}		}	}	for(int k=0;k<BytesPerPixel;k++){		for(int i=0;i<Sizeh;i++){			for(int j=0;j<Sizew;j++){					if(k==0){						// red channel					if(Imagedata[i][j][k] >= (mode[k] - 6) && Imagedata[i][j][k] <= (mode[k] + 6)){						Binary_image[i][j][k] = 0;					}					else{						Binary_image[i][j][k] = 255;					}				}					else if(k==1){					// green channel					if(Imagedata[i][j][k] >= (mode[k] - 6) && Imagedata[i][j][k] <= (mode[k] + 6)){						Binary_image[i][j][k] = 0;					}					else{						Binary_image[i][j][k] = 255;					}				}				else if(k==2){					// blue channel					if(Imagedata[i][j][k] >= (mode[k] - 6) && Imagedata[i][j][k] <= (mode[k] + 6)){						Binary_image[i][j][k] = 0;					}					else{						Binary_image[i][j][k] = 255;					}				}							}		}	}	/// ______________________________________________________________________________________________	unsigned char NewImagedata[Sizeh][Sizew];	/// Converting to Grayscale ////	for(int i=0;i<Sizeh;i++){		for(int j=0;j<Sizew;j++){			NewImagedata[i][j] = 0.2989*Binary_image[i][j][0] + 0.5870*Binary_image[i][j][1] + 0.1140*Binary_image[i][j][2];			if(NewImagedata[i][j] > 100){				NewImagedata[i][j] = 255;					// white pixel			}			else{				NewImagedata[i][j] = 0;						// black background			}		}	}		/////////////////////////////////////////////////////////////////////////////////////////////		// Median filter	unsigned char newFiltered_Image[Sizeh][Sizew];	for(int i=0;i<Sizeh;i++){		for(int j=0;j<Sizew;j++){			newFiltered_Image[i][j] = 0;		}	}	for(int iter =0;iter <1;iter++){		for(int l=2;l< Sizeh-2;l++){			for(int w=2;w< Sizew-2;w++){				// 5 x 5 window				for(int i=-2;i<3;i++){					for(int j=-2;j<3;j++){						v.push_back(NewImagedata[i+l][j+w]);					}				}				// sorting				sort(v.begin(),v.end());				// median				newFiltered_Image[l][w] = (unsigned char)v[12];				v.clear();			}		}		for(int i=0;i<Sizeh;i++){			for(int j=0;j<Sizew;j++){				NewImagedata[i][j] = newFiltered_Image[i][j];			}		}	}			// Write image data (filename specified by second argument) from image data matrix	if (!(file=fopen(argv[2],"wb"))) {		cout << "Cannot open file: " << argv[2] << endl;		exit(1);	}	fwrite(NewImagedata,sizeof(unsigned char), (Sizew)*(Sizeh), file);	fclose(file);	return 0;}